Parsing:
1. Finde alle definitions
2. Parse og validere alle definitions
3. På forespørgsel, så skal den kunne give
3a en text representation (til transmition over netværk)
3b En objekt graf til GameModel, således at en definition kan spilles. Dvs. fra GameDefinition kan e.g. hives alle kort(constructed), samt et frisk board (constructed), 
   + hvad end der nu ellers skal definieres i en fil.




Notes:
På mappet kan startpositions også angives med et ID. Det ID kan så listes i filen, og det udgør rækkefølgen spillere vælges i.
Alternativt skulle dette nok bare være listen Characters er defineret i, og så kan deres startposition på mappet angives ved eg 'C1'.

Dependency injection til lokal test.
Så kan man injecte et object som er Player, som i stedet for en TCP forbindelse læser og skriver i terminal eller bare automatisk test.



NIO2 er nice til filoverførsel, f.eks. billeder



http://tutorials.jenkov.com/java-nio/nio-vs-io.html
[5:03:30 PM] Rasmus  Ljungmann Pedersen: Hvis nu der er buffer i javas tcp stack, så kunne serveren vel godt være 1 trådet ?
[5:03:56 PM] Rasmus  Ljungmann Pedersen: Altså, server siger noget til klien1, og så bare stå og blokere til klient1 har svaret, så videre til klient2, samme procedure
[5:03:59 PM] santa_cloud: Well, ja, for den skal jo kun læse/skrive til en socket af gangen, anyways
[5:04:30 PM] Rasmus  Ljungmann Pedersen: Jeg har så ingen mulighed fra andre klienter for at pinge serveren og rent faktisk få et svar på status om game state
[5:04:37 PM] Rasmus  Ljungmann Pedersen: hvis ikke det er den klients tur
[5:05:29 PM] santa_cloud: Det tror jeg også sagtens kan fikses.. Det er jo bare et spørgsmål om at serveren kigger på de andre sockets, indtil den får svar fra den den venter på
[5:05:51 PM] Rasmus  Ljungmann Pedersen: eh, hvordan vil du gøre det+
[5:06:36 PM] santa_cloud: while(true) {
if(currentPlayer.ready()) { 
       foo()
} else { 
        //snak med de andre
}
[5:07:14 PM] Rasmus  Ljungmann Pedersen: okay, så ready() skulle så læse hvad der var kommet på socketen, afgøre om transmissionen var færdig, og så agere ud fra det.
[5:07:24 PM] santa_cloud: Yeah, det forestiller jeg mig
[5:07:44 PM] santa_cloud: Ellers ville serveren jo være fuldstændigt blocked, indtil en spiller færdiggør sin tur
[5:07:53 PM] Rasmus  Ljungmann Pedersen: Hvordan holder jeg styr på hvad gamestaten er så ?
[5:07:54 PM] Rasmus  Ljungmann Pedersen: Ja
[5:07:58 PM] Rasmus  Ljungmann Pedersen: Det var det jeg havde tænkt
[5:08:13 PM] Rasmus  Ljungmann Pedersen: For det ville jo være super simpelt
[5:08:30 PM] santa_cloud: Du opdatere kun gamestate, når currentPlayer rent faktisk gør noget, indtil da, kan du sagtens sende gamestate til de andre spillere
[5:08:35 PM] santa_cloud: de kan bare ikke ændre på den
[5:09:14 PM] Rasmus  Ljungmann Pedersen: Så jeg skal have en statemachine som afgører hvor langt i afviklingen af en tur jeg er ?
[5:09:30 PM] santa_cloud: det tror jeg ikke du kommer udenom, uanset hvordan du gør det
[5:10:23 PM] Rasmus  Ljungmann Pedersen: Hvis serveren bare var blocking ville det jo være så simpelt som at afvikle en funktion, i og med statemachines udførsel ville svare til en path igennem blocking kode.
[5:10:25 PM] Rasmus  Ljungmann Pedersen: Right?
[5:10:58 PM] santa_cloud: Jo
[5:11:45 PM] santa_cloud: Men lukker clienten ikke socket forbindelsen, hvis ikke der bliver sendt nogen form for keep-alive eller lign.?
[5:11:59 PM] santa_cloud: Ved ikke om man kan holde en socket åben, uden nogen form for data transmition
[5:12:21 PM] Rasmus  Ljungmann Pedersen: Hmm... Hvis man sætter uendelig timeout ?
[5:12:26 PM] Rasmus  Ljungmann Pedersen: Kan man ikke løse det sådan ?
[5:12:46 PM] santa_cloud: Mjoh, men er det specielt stabilt? så ved man heller ikke hvis serveren faktisk crasher :P
[5:13:53 PM] santa_cloud: Og serveren skal vel egentligt også kunne vide om en client er disconnected før tid, så spillet enten kan stoppes eller der kan gøres et eller andet smart
[5:13:54 PM] Rasmus  Ljungmann Pedersen: Det er ikke en ret nice løsning, men vi snakker LAN brug (speciale wise i hvert fald), så tror ikke det ville blive såååå stort et problem. Men altså, nej. Det er ikke en god løsning. Hvordan ville du håndtere keep alive ?
[5:14:12 PM] Rasmus  Ljungmann Pedersen: Tænker den får en socket closed exception så ?
[5:14:31 PM] Rasmus  Ljungmann Pedersen: (hvis der er noget der hedder det, og ved heller ikke hvad der skulle til for at trigger det)
[5:15:57 PM] santa_cloud: Keep alive, kommer vel helt an på hvordan sockets faktisk fungere
[5:19:16 PM] Rasmus  Ljungmann Pedersen: http://tutorials.jenkov.com/java-nio/nio-vs-io.html
[5:19:25 PM] Rasmus  Ljungmann Pedersen: Java NIO kunne godt lyde nice
[5:19:37 PM] santa_cloud: Det er også Java's nye in/out shizzle :P
[5:21:13 PM] santa_cloud: Men virker da som om at du kan bruge nio til at lave noget i stil med hvad jeg foreslog?
[5:23:27 PM] Rasmus  Ljungmann Pedersen: Ja
[5:23:34 PM] Rasmus  Ljungmann Pedersen: Eller IO til det jeg foreslog=)
[5:23:50 PM] santa_cloud: Ya



StateMachine og currentPlayer i Model (eller evt statemachine per player?)
Public announcements sendes til alle andre (løbende, eller afslutningsvis)
Private announcements sendes privat (løbende, da state machine afhænger af dette)